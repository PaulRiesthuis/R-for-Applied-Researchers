# R and Rstudio environment {#sec-r-and-rstudio-environment}

## R and Rstudio

When I first started working with R, I remember being confused by the fact that many people recommended downloading both R and RStudio. I didn’t fully understand why RStudio was necessary.

The simplest way to think about it is that RStudio is a convenient interface (an IDE) that makes it easier to write, run, and manage your R code. You use R as the underlying language, and RStudio as the environment that helps you work with that language more effectively.

The Rstudio looks as follows: ![Rstudio Classic Interface](rstudio_interface.jpeg)

The RStudio interface is divided into **four main sections** that help you write, run, and manage your R code efficiently:

1)  **Source**

-   This is where you write and edit your R scripts or Quarto documents.
-   Think of it like a “text editor” for your code.
-   You can save your scripts, organize your work, and run lines or sections of code from here.

2)  **Console**

-   This is where R actually executes your code.
-   You can type commands directly and see immediate results.
-   It’s perfect for testing small pieces of code or quickly checking something.

3)  **Environment**

-   This section shows all the variables, data frames, and objects currently stored in your R session.
-   It helps you keep track of what data and results you have available.
-   Some tabs also show your command history, so you can easily reuse previous commands.

4)  **Output**

-   This section displays plots, graphs, and other outputs generated by your code.
-   It also includes tabs for files, packages, help, and viewer windows.
-   You can inspect your results visually and navigate your project files from here.

**Summarized**:

A simple way to remember the sections:

1.  **Source** → write code
2.  **Console** → run code
3.  **Environment** → see your variables
4.  **Output** → see results and plots

## Coding {#sec-coding}

So, in the source section we can actually code variables. The possibilities here are endless. That is, we can code a single number to be assigned to a variable name "y" but also conduct entire structural equation models, multilevel models, etc. Let's start with some basics and most essential.

### Example 1: Variable with single number {#sec-example-1-variable-with-single-number}

-   In R we use "\<-" instead of "=" to assign variables.

-   You can copy code always by clicking the icon in the upper right of the code chunk.

```{r, echo = T, message = F}
x <- 7 
x
```

**Tip**: You can run code by selecting a line and pressing **Ctrl + Enter** (Windows) or **Cmd + Enter** (Mac).

### Example 2: Variable with multiple numbers {#sec-example-2-variable-with-multiple-numbers}

This is also known as a **single row vector**

```{r}
row_vec <- c(1,2,3,4,5)
row_vec
```

### Example 3: row vs column vectors {#sec-example-3-row-vs-column-vectors}

In R, the vectors we create are **row vectors** by default. Sometimes, it’s useful to create a **column vector** (a vector arranged vertically), especially when working with matrices or data frames.

```{r}
col_vec <- matrix(c(1, 2, 3, 4, 5), ncol = 1)
col_vec
```

**Explanation:**

-   **Row vector:** A simple vector created with `c()`; elements are arranged horizontally when printed.
-   **Column vector:** Created using `matrix()` with `ncol = 1`; elements are arranged vertically.
-   Vectors are the **building blocks** for matrices and data frames in R.
-   **Tip**: In psychological research, a **column often represents a variable** (e.g., Age, Score) and a **row represents a participant**.

### Example 4: Dataframes {#sec-example-4-dataframes}

A **data frame** is like a table in R. It can store **columns of different types** (numeric, character, logical) and is one of the most common ways to organize data for analysis.

```{r}
df <- data.frame(
Name = c("Alice", "Bob", "Charlie"),
Age = c(25, 30, 22),
Passed = c(TRUE, FALSE, TRUE)
)

df

```

**Explanation:**

-   `data.frame()` creates a table-like structures
-   Columns can have **different types** (numbers, text, logical values).

### Example 5: **Accessing and Subsetting Data** {#sec-example-5-accessing-and-subsetting-data}

-   You can access columns of a dataframe with `$`, e.g., `df$Age`.

```{r}
df$Age
df$Passed
```

Each column is treated as a vector, so you can perform operations on it just like a normal vector.

-   You can access rows using **row indices**, e.g., `df[1, ]`.

```{r}
df[1, ]
df[2, ]
```

The syntax is df\[row, column\]. Leaving the column blank selects all columns (or vice versa).

-   You can filter rows using logical conditions. For example, to select all participants who passed:

```{r}
df[df$Passed == TRUE, ]
```

Some useful logical operators in R:

-   == → equal to
-   != → not equal to
-   \> → greater than
-   \< → less than
-   \>= → greater than or equal to
-   \<= → less than or equal to
-   & → AND
-   \| → OR

Example: Select participants who passed or are older than 25:

```{r}
df[df$Passed == TRUE & df$Age > 24, ]
```

There are also packages in R that others have created that also perform these data manipulations but also more advanced such as "**dplyr**".

-   For example, we can **select** Age or Passed columns:

```{r, echo =T, message =F}
# install.packages(dplyr) # Run the code before without "#" to install the package
library(dplyr) # This is to call the packages

df %>% select(Age)
df %>% select(Passed)
```

-   Or we can **filter** only participants who passed the test:

    ```{r}
    df %>% filter(Passed == TRUE)
    ```

-   Or **select** and **filter** simultaneously for which we need "%\>%" (pipe) operator:

    ```{r}
    df %>%
    filter(Passed == TRUE) %>%
    select(Name, Age)
    ```

**Why dplyr is useful:**

-   Syntax is **more readable** than base R, especially for beginners.
-   You can **chain multiple operations** with `%>%`, which makes your code look like a step-by-step pipeline.
-   Works well for **larger datasets** and more complex filtering.

There are many powerful functions in dplyr, and we’ll explore them gradually throughout the book. However, tools like large language models can be extremely helpful when you want to automate your workflow. You can simply describe—in plain language—what you want to do (e.g., “filter rows where Age is above 30 and select only the Name column”), and the model can generate the corresponding R code for you.

### Example 6: **Descriptive statistics** {#sec-example-6-descriptive-statistics}

It is also quite easy to compute **mean, median, standard deviation** or other statistics:

```{r}
mean(df$Age)
median(df$Age)
sd(df$Age)
summary(df)

```

There are also packages that will automatically summarise your data and provide additional information such as "**psych**".

```{r, echo = T, message=F}
# install.packages(psych) # Run the code before without "#" to install the package

library(psych)
describe(df)


```

### Summary and conclusion {#sec-summary-and-conclusion}

In this introductory chapter, we explored the basic structure and functionality of R and RStudio. You learned how the main interface is organized, how to write and run simple pieces of code, and how to create and manipulate some of the most fundamental data structures in R, such as vectors and data frames. We also introduced essential tools for inspecting and filtering data, both using base R and the more readable dplyr syntax. These skills form the foundation of nearly all data analysis work in R. In the next chapter, we will build on this foundation by working with a real dataset—importing it, exploring it, and preparing it for analysis—so you can see how these tools apply to actual research scenarios.
